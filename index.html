<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Ch√∫c m·ª´ng 20/10 b·∫°n Th·∫£o</title>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      background-color: black;
      overflow: hidden;
      font-family: 'Dancing Script', cursive;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    .message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 28px;
      text-align: center;
      line-height: 1.6;
      font-weight: 400;
      white-space: pre-line;
    }

    .message span {
      opacity: 0;
      animation: fadeIn 0.3s forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <canvas id="heartCanvas"></canvas>
  <canvas id="petalCanvas"></canvas>
  <canvas id="smallHeartCanvas"></canvas>
  <div class="message" id="message"></div>

  <script>
    // ----- Canvas c·ª° ƒë·∫ßy m√†n -----
    const W = window.innerWidth;
    const H = window.innerHeight;

    // ----- Tr√°i tim pixel l·ªõn -----
    const heartCanvas = document.getElementById("heartCanvas");
    const ctx = heartCanvas.getContext("2d");
    heartCanvas.width = W;
    heartCanvas.height = H;

    const pixelSize = 1;
    const heartScale = 13;
    const centerX = W / 2;
    const centerY = H / 2;
    const pixels = [];

  function heartFunction(t) {
      const x = 17 * Math.pow(Math.sin(t), 3);
      const y = 14 * Math.cos(t) - 6 * Math.cos(2 * t) - 3 * Math.cos(3 * t) - Math.cos(4 * t);
      return { x, y };
    }

    for (let i = 0; i < 2000; i++) {
      const t = Math.random() * Math.PI * 4;
      const { x, y } = heartFunction(t);
      pixels.push({
        baseX: centerX + x * heartScale,
        baseY: centerY - y * heartScale,
        offsetX: (Math.random() - 0.5) * 3,
        offsetY: (Math.random() - 0.5) * 3,
        speedX: (Math.random() - 0.5) * 2,
        speedY: (Math.random() - 0.5) * 2,
        color: Math.random() > 0.5 ? "#ff69b4" : "#ff1493"
      });
    }

    function animateHeart() {
      ctx.clearRect(0, 0, W, H);
      for (let p of pixels) {
        p.offsetX += p.speedX;
        p.offsetY += p.speedY;
        if (Math.abs(p.offsetX) > 10 || Math.abs(p.offsetY) > 10) {
          p.speedX *= -1;
          p.speedY *= -1;
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(p.baseX + p.offsetX, p.baseY + p.offsetY, pixelSize, pixelSize);
      }
      requestAnimationFrame(animateHeart);
    }
    animateHeart();

    // ----- Hoa ƒë√†o -----
    const petalCanvas = document.getElementById("petalCanvas");
    const pctx = petalCanvas.getContext("2d");
    petalCanvas.width = W;
    petalCanvas.height = H;

    const petals = [];
    const petalCount = 250;
    const colors = ["#ffc0cb", "#ffb6c1", "#ff69b4", "#ffb7d5", "#ff8fa3"];

    class Petal {
      constructor() { this.reset(); }
      reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * -H;
        this.size = Math.random() * 8 + 4;
        this.speedY = Math.random() * 2 + 2.5;
        this.speedX = Math.random() * 1.5 + 1;
        this.angle = Math.random() * Math.PI * 2;
        this.spin = (Math.random() - 0.5) * 0.3;
        this.color = colors[Math.floor(Math.random() * colors.length)];
      }
      update() {
        this.y += this.speedY;
        this.x += this.speedX + Math.sin(this.y * 0.02) * 0.5;
        this.angle += this.spin;
        if (this.x > W + 50 || this.y > H) {
          this.reset();
          this.x = -20;
        }
      }
      draw() {
        pctx.save();
        pctx.translate(this.x, this.y);
        pctx.rotate(this.angle);
        pctx.scale(1, 0.7);
        pctx.beginPath();
        pctx.moveTo(0, 0);
        pctx.quadraticCurveTo(this.size / 2, -this.size / 2, 0, -this.size);
        pctx.quadraticCurveTo(-this.size / 2, -this.size / 2, 0, 0);
        pctx.fillStyle = this.color;
        pctx.fill();
        pctx.restore();
      }
    }

    for (let i = 0; i < petalCount; i++) petals.push(new Petal());

    function animatePetals() {
      pctx.clearRect(0, 0, W, H);
      petals.forEach(p => {
        p.update();
        p.draw();
      });
      requestAnimationFrame(animatePetals);
    }
    animatePetals();

    // ----- Tr√°i tim nh·ªè khi hi·ªán ch·ªØ -----
    const smallHeartCanvas = document.getElementById("smallHeartCanvas");
    const sctx = smallHeartCanvas.getContext("2d");
    smallHeartCanvas.width = W;
    smallHeartCanvas.height = H;

    const smallHearts = [];

    function drawSmallHeart(x, y, size, color) {
      sctx.save();
      sctx.translate(x, y);
      sctx.beginPath();
      sctx.moveTo(0, size / 4);
      sctx.bezierCurveTo(size / 2, -size / 2, size, size / 3, 0, size);
      sctx.bezierCurveTo(-size, size / 3, -size / 2, -size / 2, 0, size / 4);
      sctx.fillStyle = color;
      sctx.fill();
      sctx.restore();
    }

    function spawnSmallHearts() {
      for (let i = 0; i < 30; i++) {
        smallHearts.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 10,
          color: ["#ff6666", "#b30000", "#ffcccc"][Math.floor(Math.random() * 3)],
          alpha: 1,
          life: 0
        });
      }
    }

    function animateSmallHearts() {
      sctx.clearRect(0, 0, W, H);
      for (let h of smallHearts) {
        h.life += 0.02;
        h.alpha -= 0.015;
        drawSmallHeart(h.x, h.y - Math.sin(h.life * 3) * 5, h.size, h.color);
      }
      // X√≥a nh·ªØng tim ƒë√£ m·ªù
      for (let i = smallHearts.length - 1; i >= 0; i--) {
        if (smallHearts[i].alpha <= 0) smallHearts.splice(i, 1);
      }
      requestAnimationFrame(animateSmallHearts);
    }
    animateSmallHearts();

    // ----- Hi·ªáu ·ª©ng ch·ªØ -----
    const messageEl = document.getElementById("message");
    const text = "Ch√∫c m·ª´ng 20/10 Th·∫£o xinh ƒë·∫πp nha,\nb·∫°n l√† b√¥ng hoa ƒë·∫πp nh·∫•t tr√™n ƒë·ªùi üå∏";

    function showMessage() {
      messageEl.innerHTML = "";
      text.split("").forEach((char, i) => {
        const span = document.createElement("span");
        span.textContent = char;
        span.style.animationDelay = `${i * 0.05}s`;
        messageEl.appendChild(span);
      });

      // Khi ch·ªØ b·∫Øt ƒë·∫ßu xu·∫•t hi·ªán ‚Üí sinh tim nh·ªè
      spawnSmallHearts();

      // Sau khi ch·ªØ xu·∫•t hi·ªán xong ‚Üí x√≥a v√† l·∫∑p l·∫°i
      const totalDuration = text.length * 50 + 2000;
      setTimeout(() => {
        messageEl.innerHTML = "";
        setTimeout(showMessage, 1000);
      }, totalDuration);
    }

    showMessage();

    window.addEventListener("resize", () => {
      heartCanvas.width = petalCanvas.width = smallHeartCanvas.width = window.innerWidth;
      heartCanvas.height = petalCanvas.height = smallHeartCanvas.height = window.innerHeight;
    });
  </script>
  <script>
  // T·ª± ƒë·ªông ghi l·∫°i hi·ªáu ·ª©ng tr√™n to√†n trang trong 6 gi√¢y
  async function recordToWebM() {
    const stream = document.body.captureStream(30); // 30 FPS
    const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
    let chunks = [];

    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = e => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);

      // T·∫°o link t·∫£i file .webm
      const a = document.createElement('a');
      a.href = url;
      a.download = 'heart_animation.webm';
      a.click();
      URL.revokeObjectURL(url);
    };

    recorder.start();
    await new Promise(resolve => setTimeout(resolve, 6000)); // Quay 6 gi√¢y
    recorder.stop();
  }

  // T·ª± ƒë·ªông ch·∫°y ghi h√¨nh sau 2 gi√¢y ƒë·ªÉ k·ªãp load hi·ªáu ·ª©ng
  setTimeout(recordToWebM, 2000);
</script>
</body>
</html>
